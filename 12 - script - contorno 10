import cv2
import time
import numpy as np
import csv

# Caminho do vídeo
caminho_video = r"C:\Users\Ricardo Gomes\Desktop\output_video_MaskInvertida_v1.avi"

# Parâmetros ajustáveis
DIAMETRO_MINIMO = 40
DIAMETRO_MAXIMO = 150
VELOCIDADE_VIDEO = 10
BRILHO = 1
CONTRASTE = 1.7

# Criar arquivo CSV para salvar os dados
csv_file = "contagem_bolhas.csv"
with open(csv_file, mode='w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(["Frame", "Quantidade de Bolhas", "Diametro Medio (pixels)"])

# Carregar o vídeo
video = cv2.VideoCapture(caminho_video)
if not video.isOpened():
    print("Não foi possível carregar o vídeo. Verifique o caminho.")
else:
    tempo_inicio = time.time()
    contador_objetos = 0
    frame_index = 0
    
    while True:
        ret, frame = video.read()
        if not ret:
            print("Fim do vídeo ou erro ao ler o quadro.")
            break

        altura, largura = frame.shape[:2]

        # Converter para escala de cinza
        frame_cinza = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        # Ajustar contraste e brilho
        frame_ajustado = cv2.convertScaleAbs(frame_cinza, alpha=CONTRASTE, beta=BRILHO)

        # Suavizar a imagem para reduzir ruídos
        frame_suavizado = cv2.GaussianBlur(frame_ajustado, (5, 5), 0)

        # Detecção de bordas com Canny
        bordas = cv2.Canny(frame_suavizado, 30, 100)

        # Encontrar contornos
        contornos, _ = cv2.findContours(bordas, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

        frame_contornos = frame.copy()
        diametros = []
        contador_temp = 0
        
        for contorno in contornos:
            (x, y), raio = cv2.minEnclosingCircle(contorno)
            diametro = 2 * raio
            
            if DIAMETRO_MINIMO <= diametro <= DIAMETRO_MAXIMO:
                cv2.drawContours(frame_contornos, [contorno], -1, (0, 255, 0), 2)
                diametros.append(diametro)
                contador_temp += 1
        
        # Calcular diâmetro médio das bolhas
        diametro_medio = np.mean(diametros) if diametros else 0
        
        # Atualizar contador a cada 0.5 segundos
        if time.time() - tempo_inicio >= 0.5:
            contador_objetos = contador_temp
            tempo_inicio = time.time()

        # Salvar contagem e diâmetro médio no CSV
        with open(csv_file, mode='a', newline='') as file:
            writer = csv.writer(file)
            writer.writerow([frame_index, contador_objetos, round(diametro_medio, 2)])
        
        # Atualizar frame index
        frame_index += 1

        # Redimensionar a imagem para visualização
        novo_largura = 1000
        nova_altura = int(altura * (novo_largura / largura))
        frame_redimensionado = cv2.resize(frame_contornos, (novo_largura, nova_altura))

        # Mostrar vídeo com contornos
        cv2.imshow("Video com Contagem de Bolhas", frame_redimensionado)

        # Tela com contagem de objetos
        tela_contagem = np.zeros((300, 600, 3), dtype=np.uint8)
        texto_contagem = f"Bolhas: {contador_objetos}, Diametro Medio: {round(diametro_medio, 2)} px"
        cv2.putText(tela_contagem, texto_contagem, (20, 100), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
        cv2.imshow("Contagem de Bolhas", tela_contagem)

        # Parar com a tecla 'q'
        if cv2.waitKey(VELOCIDADE_VIDEO) & 0xFF == ord('q'):
            break

    # Liberar vídeo e fechar janelas
    video.release()
    cv2.destroyAllWindows()

print(f"Arquivo CSV salvo como {csv_file}")
