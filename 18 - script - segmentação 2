import cv2
import numpy as np
import os
from tkinter import Tk, filedialog

# Função para selecionar múltiplas imagens
def selecionar_imagens():
    Tk().withdraw()  
    caminhos = filedialog.askopenfilenames(title="Selecione as imagens", filetypes=[("Imagens", "*.bmp;*.jpg;*.png")])
    return list(caminhos)

# Função para detectar e desenhar contornos
def aplicar_contornos(img, tamanho_minimo=500):
    bordas = cv2.Canny(cv2.cvtColor(img, cv2.COLOR_BGR2GRAY), 50, 150)  
    img_contorno = img.copy()
    
    contornos, _ = cv2.findContours(bordas, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    
    contornos_filtrados = [contorno for contorno in contornos if cv2.contourArea(contorno) > tamanho_minimo]

    cv2.drawContours(img_contorno, contornos_filtrados, -1, (0, 255, 0), 2)  # Verde para contornos
    return img_contorno

# Função para segmentação de cor vermelha
def segmentar_vermelho(imagem):
    hsv = cv2.cvtColor(imagem, cv2.COLOR_BGR2HSV)
    
    # Intervalos de cor para vermelho (considerando que pode estar nos extremos do HSV)
    lower_red1 = np.array([0, 120, 70])
    upper_red1 = np.array([10, 255, 255])
    lower_red2 = np.array([170, 120, 70])
    upper_red2 = np.array([180, 255, 255])
    
    # Criar máscaras
    mask1 = cv2.inRange(hsv, lower_red1, upper_red1)
    mask2 = cv2.inRange(hsv, lower_red2, upper_red2)
    mask = mask1 + mask2
    
    # Aplicar a máscara à imagem original
    resultado = cv2.bitwise_and(imagem, imagem, mask=mask)
    return resultado

# Função para aplicar filtros e contornos
def aplicar_filtro_mediana(caminho):
    imagem = cv2.imread(caminho)
    if imagem is None:
        print(f"Erro ao carregar a imagem: {caminho}")
        return None
    
    # Filtro mediana para redução de ruído
    imagem_filtrada = cv2.medianBlur(imagem, 5)
    
    # Segmentação do vermelho após aplicação do filtro
    imagem_segmentada = segmentar_vermelho(imagem_filtrada)
    
    # Aplicar contornos na imagem segmentada
    imagem_contorno = aplicar_contornos(imagem_segmentada)
    
    return imagem_contorno

# Função para salvar a imagem filtrada
def salvar_imagem(imagem, caminho_original):
    pasta_saida = "imagens_processadas"
    os.makedirs(pasta_saida, exist_ok=True)
    nome_arquivo = os.path.basename(caminho_original)
    caminho_saida = os.path.join(pasta_saida, f"filtrada_{nome_arquivo}")
    cv2.imwrite(caminho_saida, imagem)
    print(f"Imagem salva em: {caminho_saida}")

# Selecionar imagens
caminhos_imagens = selecionar_imagens()

# Processar cada imagem
for caminho in caminhos_imagens:
    imagem_filtrada = aplicar_filtro_mediana(caminho)
    if imagem_filtrada is not None:
        salvar_imagem(imagem_filtrada, caminho)
       
cv2.waitKey(0)
cv2.destroyAllWindows()
